(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{114:function(e,n,t){"use strict";t.r(n),t.d(n,"MDXContext",(function(){return p})),t.d(n,"MDXProvider",(function(){return u})),t.d(n,"mdx",(function(){return f})),t.d(n,"useMDXComponents",(function(){return m})),t.d(n,"withMDXComponents",(function(){return d}));var a=t(0),o=t.n(a);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(){return(i=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e}).apply(this,arguments)}function s(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?s(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function c(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var p=o.a.createContext({}),d=function(e){return function(n){var t=m(n.components);return o.a.createElement(e,i({},n,{components:t}))}},m=function(e){var n=o.a.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},u=function(e){var n=m(e.components);return o.a.createElement(p.Provider,{value:n},e.children)},b={inlineCode:"code",wrapper:function(e){var n=e.children;return o.a.createElement(o.a.Fragment,{},n)}},h=o.a.forwardRef((function(e,n){var t=e.components,a=e.mdxType,r=e.originalType,i=e.parentName,s=c(e,["components","mdxType","originalType","parentName"]),p=m(t),d=a,u=p["".concat(i,".").concat(d)]||p[d]||b[d]||r;return t?o.a.createElement(u,l(l({ref:n},s),{},{components:t})):o.a.createElement(u,l({ref:n},s))}));function f(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var r=t.length,i=new Array(r);i[0]=h;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var c=2;c<r;c++)i[c]=t[c];return o.a.createElement.apply(null,i)}return o.a.createElement.apply(null,t)}h.displayName="MDXCreateElement"},43:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return i})),t.d(n,"metadata",(function(){return s})),t.d(n,"rightToc",(function(){return l})),t.d(n,"default",(function(){return p}));var a=t(3),o=t(8),r=(t(0),t(114)),i={title:"OpenLABEL format"},s={unversionedId:"openlabel/openlabel-format",id:"openlabel/openlabel-format",isDocsHomePage:!1,title:"OpenLABEL format",description:"OpenLABEL is a standardized annotation format developed by ASAM.",source:"@site/docs/openlabel/openlabel-format.md",slug:"/openlabel/openlabel-format",permalink:"/annotell-python/docs/openlabel/openlabel-format",editUrl:"https://github.com/annotell/annotell-python/edit/gh-pages/docs-src/docs/openlabel/openlabel-format.md",version:"current",sidebar:"docs",previous:{title:"Point clouds",permalink:"/annotell-python/docs/input-api/resources/pointclouds"},next:{title:"The Python client",permalink:"/annotell-python/docs/openlabel/python-client"}},l=[{value:"Non-sequences are sequences with one frame",id:"non-sequences-are-sequences-with-one-frame",children:[]},{value:"Stream is just another text property",id:"stream-is-just-another-text-property",children:[]},{value:"Relations",id:"relations",children:[{value:"Relations are unidirectional",id:"relations-are-unidirectional",children:[]},{value:"Groups are represented as actions",id:"groups-are-represented-as-actions",children:[]}]},{value:"Representing polygons",id:"representing-polygons",children:[]}],c={rightToc:l};function p(e){var n=e.components,t=Object(o.default)(e,["components"]);return Object(r.mdx)("wrapper",Object(a.default)({},c,t,{components:n,mdxType:"MDXLayout"}),Object(r.mdx)("p",null,"OpenLABEL is a standardized annotation format developed by ",Object(r.mdx)("a",{parentName:"p",href:"https://www.asam.net/"},"ASAM"),".\nIt comes with in-depth ",Object(r.mdx)("a",{parentName:"p",href:"http://www.asam.net/project-detail/asam-openlabel-v100/"},"documentation")," of the format as well\nas a ",Object(r.mdx)("a",{parentName:"p",href:"https://openlabel.asam.net/V1-0-0/schema/openlabel_json_schema.json"},"json schema"),", which can be used to ensure\nthat the format is valid."),Object(r.mdx)("p",null,"Even though OpenLABEL is a strict format there is still some room for interpretation. In this section we try to clarify\nsome of these parts and explain the choices that we have made within the standard."),Object(r.mdx)("h2",{id:"non-sequences-are-sequences-with-one-frame"},"Non-sequences are sequences with one frame"),Object(r.mdx)("p",null,"Due to reasons of simplicity we have made the choice to treat non-sequences in the same way as sequences. This\nmeans that non-sequences are represented as a sequence with only one frame. Only data such as ",Object(r.mdx)("inlineCode",{parentName:"p"},"name")," and ",Object(r.mdx)("inlineCode",{parentName:"p"},"type")," are defined\nin the top level element keys. All other information is stored under frames, see example below"),Object(r.mdx)("pre",null,Object(r.mdx)("code",{parentName:"pre",className:"language-json"},'{\n    "objects": {\n        "0": {\n            "name": "car-0",\n            "type": "Car"\n        }\n    },\n    "frames": {\n        "0": {\n            "objects": {\n                "0": {"object_data": {...}}\n            }\n        }\n    }\n}\n')),Object(r.mdx)("h2",{id:"stream-is-just-another-text-property"},"Stream is just another text property"),Object(r.mdx)("p",null,"The ",Object(r.mdx)("inlineCode",{parentName:"p"},"stream")," property is used to indicate which stream/sensor/source that the geometry och property was annotated in.\nFor example here is an object with a point that has been annotated in a stream with the name ",Object(r.mdx)("inlineCode",{parentName:"p"},"Camera"),". Note that all\ncorresponding attributes for the geometry have also been annotated in the same stream."),Object(r.mdx)("pre",null,Object(r.mdx)("code",{parentName:"pre",className:"language-json"},'{\n    "object_data": {\n        "point2d": [\n            {\n                "name": "point-4d2d325f",\n                "val": [300.5300, 286.4396],\n                "attributes": {\n                    "text": [\n                        {"name": "stream", "val": "Camera"},\n                        {"name": "Color", "val": "Black"}\n                    ]\n                }\n            }\n        ]\n    }\n}\n')),Object(r.mdx)("h2",{id:"relations"},"Relations"),Object(r.mdx)("p",null,"We consider two types of relations; unidirectional relations between two objects and group relations.\nIn addition to these, there is a need to represent relation properties even when they are not actually pointers to other\nobjects but rather take properties such as ",Object(r.mdx)("inlineCode",{parentName:"p"},"Inconclusive"),", ",Object(r.mdx)("inlineCode",{parentName:"p"},"Nothing")," or ",Object(r.mdx)("inlineCode",{parentName:"p"},"Unclear"),"."),Object(r.mdx)("h3",{id:"relations-are-unidirectional"},"Relations are unidirectional"),Object(r.mdx)("p",null,"Relations are unidirectional, meaning that if an object, ",Object(r.mdx)("inlineCode",{parentName:"p"},"object1"),", has a relation to another object, ",Object(r.mdx)("inlineCode",{parentName:"p"},"object2"),", it does\nnot mean that ",Object(r.mdx)("inlineCode",{parentName:"p"},"object2")," has a relation to ",Object(r.mdx)("inlineCode",{parentName:"p"},"object1"),". Below follows an example where ",Object(r.mdx)("inlineCode",{parentName:"p"},"car-0")," is following ",Object(r.mdx)("inlineCode",{parentName:"p"},"car-1")," and\nit is unclear whether ",Object(r.mdx)("inlineCode",{parentName:"p"},"car-2")," is following another car or not."),Object(r.mdx)("pre",null,Object(r.mdx)("code",{parentName:"pre",className:"language-json"},'{\n    "objects": {\n        "0": {"name": "car-0", "type": "Car"},\n        "1": {"name": "car-1", "type": "Car"},\n        "2": {"name": "car-2", "type": "Car"},\n    },\n    "relations": {\n        "0": {\n            "name": "0",\n            "type": "isFollowing",\n            "rdf_subjects": [{"type": "object", "uid": "0"}],\n            "rdf_objects": [{"type": "object", "uid": "1"}]\n        },\n        "1": {\n            "name": "1",\n            "type": "isFollowing",\n            "rdf_subjects": [{"type": "object", "uid": "2"}],\n            "rdf_objects": [{"type": "object", "uid": "Unclear"}]\n        }\n    }\n}\n')),Object(r.mdx)("h3",{id:"groups-are-represented-as-actions"},"Groups are represented as actions"),Object(r.mdx)("p",null,"Group relations are relations where objects can be seen as belonging to a group. There is then a need for an abstract\nconcept that describes the group. OpenLABEL suggests the use of actions for this in such a way that each object in the\ngroup has a relation of type ",Object(r.mdx)("inlineCode",{parentName:"p"},"isSubjectOfAction")," to this action. Below follows an example where two ",Object(r.mdx)("inlineCode",{parentName:"p"},"lane-0")," and ",Object(r.mdx)("inlineCode",{parentName:"p"},"lane-1"),"\nbelong to the same road, while it is unclear whether ",Object(r.mdx)("inlineCode",{parentName:"p"},"lane-2")," belongs to a road."),Object(r.mdx)("pre",null,Object(r.mdx)("code",{parentName:"pre",className:"language-json"},'{\n    "objects": {\n        "0": {"name": "lane-0", "type": "Lane"},\n        "1": {"name": "lane-1", "type": "Lane"},\n        "2": {"name": "lane-2", "type": "Lane"}\n    },\n    "relations": {\n        "0": {\n            "name": "0",\n            "type": "isSubjectOfAction",\n            "rdf_subjects": [{"type": "object", "uid": "0"}],\n            "rdf_objects": [{"type": "action", "uid": "0"}]\n        },\n        "1": {\n            "name": "1",\n            "type": "isSubjectOfAction",\n            "rdf_subjects": [{"type": "object", "uid": "1"}],\n            "rdf_objects": [{"type": "action", "uid": "0"}]\n        },\n        "2": {\n            "name": "2",\n            "type": "isSubjectOfAction",\n            "rdf_subjects": [{"type": "object", "uid": "1"}],\n            "rdf_objects": [{"type": "action", "uid": "1"}]\n        }\n    },\n    "actions": {\n        "0": {"name": "", "type": "Road"},\n        "1": {"name": "Unclear", "type": "Road"}\n    }\n}\n')),Object(r.mdx)("h2",{id:"representing-polygons"},"Representing polygons"),Object(r.mdx)("p",null,"Polygons are often described as lists of geometric polygons where the first element describes the outer boundary while\nthe subsequent ones describe potential holes in the polygon. In addition, objects such as lane markings and road paintings\nare often described as multiple polygons, or multi-polygons. In order to represent such objects we use a list of geometric\npolygons where each one has the attributes ",Object(r.mdx)("inlineCode",{parentName:"p"},"polygon_id")," and ",Object(r.mdx)("inlineCode",{parentName:"p"},"is_hole"),". Below follows an example where an object consists\nof two polygons, each with one hole."),Object(r.mdx)("pre",null,Object(r.mdx)("code",{parentName:"pre",className:"language-json"},'{\n    "objects": {\n        "a6fe73b8": {\n            "name": "roadpainting-a6fe73b8",\n            "type": "RoadPainting",\n            "object_data": {\n                "poly2d": [\n                    {\n                        "name": "poly1",\n                        "val": [...],\n                        "attributes": {\n                            "text": [{"name": "polygon_id", "val": "1"}],\n                            "boolean": [{"name": "is_hole", "val": false}]\n                        }\n                    },\n                    {\n                        "name": "poly2",\n                        "val": [...],\n                        "attributes": {\n                            "text": [{"name": "polygon_id", "val": "1"}],\n                            "boolean": [{"name": "is_hole", "val": true}]\n                        }\n                    },\n                    {\n                        "name": "poly3",\n                        "val": [...],\n                        "attributes": {\n                            "text": [{"name": "polygon_id", "val": "2"}],\n                            "boolean": [{"name": "is_hole", "val": false}]\n                        }\n                    },\n                    {\n                        "name": "poly4",\n                        "val": [...],\n                        "attributes": {\n                            "text": [{"name": "polygon_id", "val": "2"}],\n                            "boolean": [{"name": "is_hole", "val": true}]\n                        }\n                    }\n                ]\n            }\n        }\n    }\n}\n\n\n')))}p.isMDXComponent=!0}}]);