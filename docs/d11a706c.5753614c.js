(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{144:function(e,t,n){"use strict";n.r(t),t.default=n.p+"assets/images/annotell-domain-c44bba0c2d6d6e72e2ca5cda095ff12b.png"},54:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return l})),n.d(t,"rightToc",(function(){return c})),n.d(t,"default",(function(){return b}));var a=n(3),r=n(8),o=(n(0),n(94)),i={id:"key_concepts",title:"Key Concepts",description:"Annotell Platform Concepts",slug:"/"},l={unversionedId:"key_concepts",id:"key_concepts",isDocsHomePage:!1,title:"Key Concepts",description:"Annotell Platform Concepts",source:"@site/docs/key_concepts.md",slug:"/",permalink:"/annotell-python/docs/",editUrl:"https://github.com/annotell/annotell-python/edit/gh-pages/docs-src/docs/key_concepts.md",version:"current",sidebar:"docs",previous:{title:"Annotell Auth",permalink:"/annotell-python/docs/annotell-auth"},next:{title:"Projects",permalink:"/annotell-python/docs/input-api/project"}},c=[{value:"Project",id:"project",children:[]},{value:"Batch",id:"batch",children:[{value:"Batch Status",id:"batch-status",children:[]}]},{value:"Request",id:"request",children:[{value:"Guideline",id:"guideline",children:[]},{value:"Task Definition",id:"task-definition",children:[]}]},{value:"Input",id:"input",children:[{value:"Input Types",id:"input-types",children:[]}]},{value:"Annotation",id:"annotation",children:[{value:"Format",id:"format",children:[]}]}],s={rightToc:c};function b(e){var t=e.components,i=Object(r.a)(e,["components"]);return Object(o.b)("wrapper",Object(a.a)({},s,i,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,Object(o.b)("img",{alt:"Annotell",src:n(144).default})),Object(o.b)("h2",{id:"project"},"Project"),Object(o.b)("p",null,"Project is the top-most concept when interfacing with the Annotell Platform. It is possible to have multiple ongoing projects, and they act as a container for other Annotell resources.\nProject setup is performed by the Annotell Professional Services team during the Guideline Agreement Process (GAP) of a new client engagement."),Object(o.b)("p",null,"To use projects within the Annotell APIs, they can be identified using an external identifier."),Object(o.b)("h2",{id:"batch"},"Batch"),Object(o.b)("p",null,"Input batches allow grouping of inputs into smaller batches within a project. By default, every project has at least one input batch."),Object(o.b)("p",null,"Ongoing projects can benefit from using batches in two ways"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Group inputs collected at the same time"),Object(o.b)("li",{parentName:"ul"},"Perform guideline or task definition changes without the need for retroactive changes.")),Object(o.b)("h3",{id:"batch-status"},"Batch Status"),Object(o.b)("table",null,Object(o.b)("thead",{parentName:"table"},Object(o.b)("tr",{parentName:"thead"},Object(o.b)("th",Object(a.a)({parentName:"tr"},{align:null}),"Status"),Object(o.b)("th",Object(a.a)({parentName:"tr"},{align:null}),"Description"))),Object(o.b)("tbody",{parentName:"table"},Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"pending"),Object(o.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"Batch has been created but is still not fully configured by Annotell. Either during project setup or requested changes")),Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"open"),Object(o.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"Batch is open for new inputs")),Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"ready"),Object(o.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"Batch has been published and no longer open for new inputs.")),Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"in-progress"),Object(o.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"Annotell has started annotation of inputs within the batch.")),Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"completed"),Object(o.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"Annotations has been completed.")))),Object(o.b)("h2",{id:"request"},"Request"),Object(o.b)("p",null,"During GAP, projects are divided into different annotation types. E.g. a project consisting of images can be divided into lane annotation and object detection. Within Annotell this is represented as a ",Object(o.b)("strong",{parentName:"p"},"Request"),".\nA Request can be viewed as a drawing tool - we divide big and complex projects into several independent annotation types.\nThis makes it possible to:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Reduce the mental strain on annotators"),Object(o.b)("li",{parentName:"ul"},"Higher bandwidth - more annotators can work on the same data in parallel"),Object(o.b)("li",{parentName:"ul"},"Build simple user interfaces")),Object(o.b)("p",null,"All of these contribute to a high level of quality while also reducing the total time needed for producing an annotation."),Object(o.b)("h3",{id:"guideline"},"Guideline"),Object(o.b)("p",null,'In order for us to produce annotations we need to know what and how to annotate. This type of information is found in something that\'s called a Guideline. A guideline contains information on what to mark (e.g. vehicles and pedestrians) as well as how (e.g. bounding box). A guideline also includes information about how to interpret the data, i.e. what does it mean that a vehicle is "heavily occluded"?'),Object(o.b)("h3",{id:"task-definition"},"Task Definition"),Object(o.b)("p",null,"Task Definition - Describes what we\u2019re annotating. How many objects? Bounding box, semantic segmentation or lines/splines? What are the properties? Task Definitions are json documents that the Annotell Professional Services team generates from the guideline. The task definition is used by the Annotell App to construct the drawing tool, and can be viewed as the machine readable quivalent of a guideline."),Object(o.b)("h2",{id:"input"},"Input"),Object(o.b)("p",null,"The Annotell Platform has support for annotating different types of data together, e.g:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"One (or more) images of the same scene from different cameras"),Object(o.b)("li",{parentName:"ul"},"Images from different cameras together with lidar point clouds")),Object(o.b)("p",null,"An ",Object(o.b)("strong",{parentName:"p"},"input")," specifies how these different resources belong together using metadata about the scene and calibrations (how sensors relate to each other). An important concept related to inputs is that of the ",Object(o.b)("em",{parentName:"p"},"frame"),". A frame is a discrete moment in time, consisting of data from several different sensors. Inputs are divided into either being ",Object(o.b)("em",{parentName:"p"},"single frame")," or ",Object(o.b)("em",{parentName:"p"},"multiple frame"),", where the latter is represented by the input type ending with ",Object(o.b)("inlineCode",{parentName:"p"},"Seq"),". In cases where you want to annotate sequences, where temporal information is important for producing the annotation, then inputs types that support multiple frames are preferrable."),Object(o.b)("p",null,"Inputs can be created via Annotell's Input API, which has support for several different types of input types."),Object(o.b)("h3",{id:"input-types"},"Input Types"),Object(o.b)("table",null,Object(o.b)("thead",{parentName:"table"},Object(o.b)("tr",{parentName:"thead"},Object(o.b)("th",Object(a.a)({parentName:"tr"},{align:null}),"Type"),Object(o.b)("th",Object(a.a)({parentName:"tr"},{align:null}),"Description"))),Object(o.b)("tbody",{parentName:"table"},Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",Object(a.a)({parentName:"tr"},{align:null}),Object(o.b)("strong",{parentName:"td"},"Cameras")),Object(o.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"A single frame consisting of images from 1-8 cameras")),Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",Object(a.a)({parentName:"tr"},{align:null}),Object(o.b)("strong",{parentName:"td"},"LidarsAndCameras")),Object(o.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"A single frame consisting of 1-3 lidar point clouds and images from 1-8 cameras")),Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",Object(a.a)({parentName:"tr"},{align:null}),Object(o.b)("strong",{parentName:"td"},"CamerasSeq")),Object(o.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"Sequence of frames, each frame consisting of images from 1-8 cameras")),Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",Object(a.a)({parentName:"tr"},{align:null}),Object(o.b)("strong",{parentName:"td"},"LidarsAndCamerasSeq")),Object(o.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"Sequence of frames, consisting of 1-3 lidar point clouds and images from 1-8 cameras")))),Object(o.b)("h2",{id:"annotation"},"Annotation"),Object(o.b)("p",null,"Inputs are annotated in requests, producing ",Object(o.b)("em",{parentName:"p"},"annotations"),". By default, annotations follow Annotell's annotation format.\nBased on client needs, custom export formats can be accommodated by Annotell Professional Services team."),Object(o.b)("h3",{id:"format"},"Format"),Object(o.b)("p",null,"The Annotell annotation format is closely linked to the Annotell task definition. The task definition determines what we are expected to save, where properties are stored and what datatype(s) the properties will be. The Annotell annotation format is saved as a JSON file and will be described according to the data types of JSON."),Object(o.b)("p",null,"The Annotell annotation is an object with the following top keys:"),Object(o.b)("table",null,Object(o.b)("thead",{parentName:"table"},Object(o.b)("tr",{parentName:"thead"},Object(o.b)("th",Object(a.a)({parentName:"tr"},{align:null}),"Property"),Object(o.b)("th",Object(a.a)({parentName:"tr"},{align:null}),"Description"))),Object(o.b)("tbody",{parentName:"table"},Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"shapes"),Object(o.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"contains information needed for drawing the shapes. Follows GeoJson standard for serialising geometric shapes, please see ",Object(o.b)("a",Object(a.a)({parentName:"td"},{href:"https://en.wikipedia.org/wiki/GeoJSON"}),"GeoJSON")," for more information.")),Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"shapeProperties"),Object(o.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"contains the property values for shapes in shapes.")),Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"properties"),Object(o.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"contains the property values for what we want to know about the input, the inputProperties of the task definition.")))),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-json"}),'{\n  "shapes": {}\n  "shapeProperties": {}\n  "properties": {}\n}\n')))}b.isMDXComponent=!0},94:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return m}));var a=n(0),r=n.n(a);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=r.a.createContext({}),b=function(e){var t=r.a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},p=function(e){var t=b(e.components);return r.a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},u=r.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,i=e.parentName,s=c(e,["components","mdxType","originalType","parentName"]),p=b(n),u=a,m=p["".concat(i,".").concat(u)]||p[u]||d[u]||o;return n?r.a.createElement(m,l(l({ref:t},s),{},{components:n})):r.a.createElement(m,l({ref:t},s))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=u;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l.mdxType="string"==typeof e?e:a,i[1]=l;for(var s=2;s<o;s++)i[s]=n[s];return r.a.createElement.apply(null,i)}return r.a.createElement.apply(null,n)}u.displayName="MDXCreateElement"}}]);